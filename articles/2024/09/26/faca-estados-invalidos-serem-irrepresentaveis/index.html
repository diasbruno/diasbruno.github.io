<html><head><title>diasbruno - Fa√ßa estados inv√°lidos serem irrepresent√°veis</title><meta name="viewport" content="width=device-width"><meta name="author" content="Bruno Dias"><meta name="title" content="diasbruno - Fa√ßa estados inv√°lidos serem irrepresent√°veis"><meta name="title" property="og:title" content="faca-estados-invalidos-serem-irrepresentaveis"><meta name="image" property="og:image" content="/images/processes-outcome.png"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="stylesheet" type="text/css" href="/css/highlight.min.css"><link rel="stylesheet" type="text/css" href="/css/milligram.css"></head><body><main><nav><div><a href="/"><h1>diasbruno</h1></a><div class="nav-links"><a class="nav-links" href="/">articles</a><a class="nav-links" href="/opensource">opensource</a><a class="nav-links" href="https://github.com/diasbruno" target="_blank">github</a></div></div></nav><section class="content"><div class="article-section"><h1>Fa√ßa estados inv√°lidos serem irrepresent√°veis</h1><div class="content-info"><span>article</span> - publish - <time class="content-datetime" datetime="2024-09-26T12:00:00Z">Sep 26, 2024</time></div><div><h2>Intro</h2>

<p>N√∫meros. Infinitos itens. Por√©m, por si s√≥, n√∫meros n√£o tem sentido (algebra?).
Para que fa√ßam sentido, definimos unidades √† o que se referem. Nisso, temos coisas cont√°veis
que s√£o infinitas, mas tamb√©m, coisas que s√£o finitas.</p>

<p>Imagine um toca CD de carro do inicio dos anos 2000. Alguns modelos possuem apenas 1 slot, e
outros, at√© 10 slots (talvez mais, mas ai √© muito chique).</p>

<p>Descrever essa capacidade (slots) como um number ou Int √© um convite para introduzir bugs.
Todos os m√©todos e vari√°veis que ser√£o declaradas assim, podem ter valores arbitr√°rios em
todos os lugares do sistema, ou, todos os lugares que utilizam dever√£o ter checks de pre e
postcondition para saber se o valor est√° dentro dos constraints espec√≠ficos a aquele item.</p>

<p>Um aplica√ß√£o tem v√°rios estados. Se fiz√©ssemos a uni√£o de todos os estados poss√≠veis em uma
√∫nica fun√ß√£o, seria praticamente imposs√≠vel compreender quantos estados a aplica√ß√£o poderia
tomar em um determinado momento.</p>

<p>A quantidade de vari√°veis seria muito grande para se quer acompanhar mentalmente o que est√°
acontecendo.</p>

<p>A maioria dos estados n√£o precisam estar dispon√≠veis o tempo todo. Essas vari√°veis precisariam
de manuten√ß√£o do momento em que ela √© inicializada, at√© quando deveria ser descartada - que
causa problemas de ‚Äústale data‚Äù (que pode causar um estado inv√°lido).</p>

<p>Dificilmente, voc√™ vai ver um code base que se preocupa com essas coisas (e sempre aparece
um bug). Alguns casos podem ser resolvidos com tipos pequenos ou &ldquo;tipos enumerados‚Äù,
outros, talvez esteja voc√™ olhando o problema de uma √∫nica perspectiva.</p>

<h2>Dados primitivos e constraints</h2>

<p><em>Number, Int, s64, u64, string, char</em> s√£o primitivos das linguagens. Alguns possuem <em>bounds</em>
(limites como <em>signed char</em> que vai de <em>-128 at√© 127</em> ou unsigned char que vai de <em>0 at√© 255</em>),
outros o limite √© ‚Äúmais aberto‚Äù.</p>

<p>N√∫meros tem limites acordo com o tamanho de storage dispon√≠vel, mas os infinitos tipos de
dados temos varias constraints que s√£o subsets (sub-conjuntos) desses outros conjuntos.
Exemplos: E-mail (string com constraint no formato e tamanho - leia a RFC e vai ver que existe
um tamanho m√≠nimo - curiosidade), idade (que a constraint varia de acordo com o contexto - se
falarmos de idade de uma pessoa, o valor est√° em entre <em>0 - idade da √∫ltima pessoa que bateu
o record de longevidade</em>, mas pode ser a idade de uma cidade, que j√° √© outro range aberto,
mas pelo menos <em>0 - infinito</em>).</p>

<p>Uma das solu√ß√µes √© a cada utiliza√ß√£o dessa informa√ß√£o adicionar <em>pre-condition</em> (se os valores
est√£o validos para a execu√ß√£o) e <em>post-condition</em> (se depois da opera√ß√£o o valor continua valido).</p>

<p>Existem linguagens como Eiffel que possui a keyword <em>require</em> e <em>ensure</em> - que se referem ao
pattern de precondition e postcondition, ou, um pattern comum de algumas linguagens de
adicionar <em>assert</em> para verificar que uma determinada propriedade n√£o viola a pre-condition.</p>

<h2>Op√ß√µes</h2>

<h3>Types</h3>

<p>Tipos s√£o um bom come√ßo. Precisamos dar contexto aos tipos de dados primitivos para
podermos efetuar opera√ß√µes com mais seguran√ßa.
Podemos definir o tipo &ldquo;n√∫mero de cart√£o de credito&rdquo; como</p>

<p>```haskell
data CreditCardNumber = CreditCardNumber String &ndash; the number
                                         Bool   &ndash; valid or not</p>

<p>validCeditCardNumber _ = False</p>

<p>class From a b where
  from :: a -> b</p>

<p>instance From String CreditCardNumber where
  from a = CreditCardNumber a (validCeditCardNumber a)</p>

<p>(from &ldquo;1111 1111 1111 1111&rdquo;) :: CreditCardNumber
&ndash; CreditCardNumber &ldquo;1111 1111 1111 1111&rdquo; False
```</p>

<p>Agora temos um contexto. Nem todas as strings v√£o ser permitidas - no que se refere a validade
do n√∫mero.
Ainda sim, existem v√°rios outros tipos para diferentes contextos.</p>

<p>```haskell
data ValidCreditCardNumber = ValidCreditCardNumber String &ndash; the number</p>

<p>validCeditCardNumber _ = False</p>

<p>class From a b where
  from :: a -> b</p>

<p>instance From String CreditCardNumber where
  from a =
    if not (validCeditCardNumber a) then
      error &ldquo;Invalid credit card number.&rdquo;
    else
      ValidCreditCardNumber a</p>

<p>(from &ldquo;1111 1111 1111 1111&rdquo;) :: ValidCreditCardNumber
&ndash; *** Exception: Invalid credit card number.
CallStack (from HasCallStack):
  error, called at <interactive>:1:1 in interactive
```</p>

<p>Agora somente n√∫meros validos passaram pelo programa, exceto que voc√™ instancie por conta
pr√≥pria (sem utilizar o <code>from</code>). Ai o problema √© seu‚Ä¶</p>

<p>Essa √© representa√ß√£o visual. De todos o elementos, somente um elemento do conjunto das
strings poss√≠veis tem um correspondente, porque s√≥ n√∫meros validos podem ser usados. O ideal
√© termos fun√ß√µes totais o m√°ximo poss√≠vel.</p>

<p><a href="/images/figure-1.png"><img src="/images/figure-1.png" alt="" /></a></p>

<p>Sair de valores infinitos e desconhecidos para um √∫nico elemento deixa tudo mais f√°cil.</p>

<p><a href="/images/figure-2.png"><img src="/images/figure-2.png" title="state machine" alt="" /></a></p>

<p>A leitura fica mais precisa: ‚ÄúCom um <em>numera√ß√£o valida</em>, execute a a√ß√£o <em>f</em>‚Äù. N√£o existe chamar a
fun√ß√£o <em>f</em>, vamos imaginar que <code>f</code> √© a fun√ß√£o <em>comprar algo</em>, com um n√∫mero de cart√£o invalido.
Toda a informa√ß√£o necess√°ria est√° embutida no tipo.</p>

<p>Ainda podemos ter casos com valida√ß√£o e ‚Äúcontinua√ß√£o‚Äù com erros, mas ter√° outro exemplo.</p>

<h3>Null object pattern</h3>

<p>Esse pattern √© mais adequado para casos onde temos objetos complexos.</p>

<p>Algumas linguagens permitem declaramos vari√°veis n√£o incializadas, que recebem o valor null ou undefined.</p>

<p>Ser deixarmos essa vari√°vel n√£o inicializada e passarmos para o restante das fun√ß√µes, elas v√£o ter que verificar
(pre-condition) se existe um valor ou n√£o.</p>

<p>Uma das principais utiliza√ß√µes:</p>

<p>Evitar que dispare exce√ß√µes do tipo ‚Äúnull pointer exception‚Äù
Disparar um erro quando o valor deveria existir, mas o objeto nulo continuou (erros previs√≠veis)
Objeto cujas as opera√ß√µes n√£o alteram o valor do resultado</p>

<p>```kotlin
open class BaseCreditCard {
  open fun buyStuff() {}
}</p>

<p>class NullCreditCard: BaseCreditCard {
  open fun buyStuff() {
    thow Error(&ldquo;Bailing out! No credit card available.&rdquo;)
  }
}</p>

<p>class CreditCard: BaseCreditCard()</p>

<p>fun findCreditCard(number: String): BaseCreditCard {
  return NullCreditCard();
}</p>

<p>fun main() {
  var card: BaseCreditCard = findCreditCard(&ldquo;1111 1111 1111 1111&rdquo;);
  card.buyStuff();
}
```</p>

<p>Esse √© um modo de garantir que sempre haver√° um objeto concreto, e, ajuda a encontrar edge cases em testes.</p>

<h3>Maybe/Option/Either/Result Functors</h3>

<p>Maybe ou option, dependendo da linguagem que voc√™ est√° usando, pode servir para casos onde o resultado de uma valida√ß√£o n√£o √© importante - somente proibir que valores inv√°lidos sejam utilizados.</p>

<p>```rust
struct ValidCreditCardNumber {
  string_number: String
}</p>

<p>fn valid(_value: &amp;str) -> bool { return true; }</p>

<p>impl From&lt;&amp;str> for ValidCreditCardNumber {
  fn from(value: &amp;str) -> Self {
    return Self { string_number: value.to_string() };
  }
}</p>

<p>trait SafeFrom<T> {
  fn from_safe(value: T) -> Option<Self> where Self: Sized;
}</p>

<p>impl SafeFrom&lt;&amp;str> for ValidCreditCardNumber {
  fn from_safe(value: &amp;str) -> Option<ValidCreditCardNumber> {
    if valid(value) { return Some(ValidCreditCardNumber:: from(value)); }
    return None;
  }
}</p>

<p>fn main() {
  let pipe = ValidCreditCardNumber::from_safe(&ldquo;111111111111111111&rdquo;)
    .map(|x| x)
    .map(|x| x);
  match pipe {
    Some (x) => printin!(&ldquo;{}&rdquo;, x.string_number),
    None => println!(&ldquo;meh&rdquo;)
  }
}
```</p>

<p>Nas figurinhas&hellip;</p>

<p><a href="/images/figure-3.png"><img src="/images/figure-3.png" title="state machine" alt="" /></a></p>

<h4>Exist√™ncia do Objeto j√° √© o seu valor (unifica√ß√£o)</h4>

<p>Este √© mais uma simplifica√ß√£o. Objetos - classes quando poss√≠vel -, s√£o a defini√ß√£o de algo.</p>

<p>Um dos exemplos mais not√≥rios s√£o GUIs.</p>

<p>Quando navegamos por p√°ginas usamos strings para marcar onde estamos.</p>

<p>```typescript
export type Pages = &ldquo;PAGE_A&rdquo; | &ldquo;PAGE_B&rdquo; | &ldquo;PAGE_C&rdquo;</p>

<p>export function getPageComponent (page: Pages) {
  switch (page) {
    case &ldquo;PAGE_A&rdquo;: return PageA;
    case &ldquo;PAGE_B&rdquo;: return PageB;
    case &ldquo;PAGE_C&rdquo;: return PageC;
  }
}
```</p>

<p>Podemos remover essas strings e utilizar as pr√≥prias classes/objetos para formar uma m√°quina de estado.</p>

<p>```typescript
export type Pages =
  | PageA
  | PageB
  | PageC</p>

<p>previousPage(PageA);
nextPage(PageC);
```</p>

<h4>Identidade de monoids</h4>

<p>Monoids possuem um elemento que n√£o influenciam no resultado de uma opera√ß√£o. O elemento identidade.</p>

<p>1 + 0 = 0 + 1 = 1</p>

<p>Ou</p>

<p>‚Äú" + ‚Äúa" = &ldquo;a&rdquo; + ‚Äú" = ‚Äúa‚Äù</p>

<p>Ou</p>

<p>Balde.Empty + Balde(Litro(x)) =
Balde(Litro(0) + Litro(x)) =
Balde(Litro(0 + x))</p>

<p>ü§∑‚Äç‚ôÇÔ∏è</p>

<h3>Conclus√£o</h3>

<p>Existem v√°rias op√ß√µes para n√£o deixa informa√ß√µes invalidas causarem problemas no projeto. Cada uma vai ser utilizada de acordo com o contexto da a√ß√£o que precisa ser feita, e, tamb√©m de acordo com o tipo de linguagem.</p>

<p>Esse conceito tamb√©m √© respons√°vel por melhora a linguagem do dom√≠nio.</p>

<h3>Refer√™ncias</h3>

<p><a href="https://www.awwsmm.com/blog/make-invalid-states-unrepresentable">https://www.awwsmm.com/blog/make-invalid-states-unrepresentable</a>
<a href="https://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/">https://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/</a>
<a href="https://geeklaunch.io/blog/make-invalid-states-unrepresentable/">https://geeklaunch.io/blog/make-invalid-states-unrepresentable/</a>
<a href="https://hugotunius.se/2020/05/16/making-invalid-state-unrepresentable.html">https://hugotunius.se/2020/05/16/making-invalid-state-unrepresentable.html</a></p>
</div></div></section></main><script type="application/javascript" src="/js/highlight.min.js"></script></body></html>